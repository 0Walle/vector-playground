<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Playground</title>
    <link rel="stylesheet" href="mathquill/mathquill.css"/>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <script src="mathquill/mathquill-basic.js"></script>
    <script src="defs.js"></script>
    <script src="parser.js"></script>
    <style>
        body {
            margin: 0px;
            background-color: #002b36;
        }

        #view {
            display: flex;
            flex-direction: row;
            width: 100%;
            height: 100vh;
        }

        #defs {
            min-width: 300px;
            border-right: 1px solid #839496;
            display: flex;
            flex-direction: column;
            max-height: 100vh;
            overflow-y: scroll;
            scrollbar-width: none;
        }

        #defs div {
            color: #fdf6e3;
            font-size: 115%;
            border-bottom: 1px solid #657b83;
            padding: 15px;
        }

        #box-container {
            width: 100%;
        }

        #objs {
            position: absolute;
            z-index: 10;
        }

        .math-field {
            border: none;
            box-shadow: none !important;
            width: 100%;
        }

        span .mq-cursor {
            border-left: 1px solid #fdf6e3 !important;
        }
    </style>
</head>
<body oncontextmenu="return false;">
    <div id="view">
        <div id="defs">
            <div onclick="new_object()" id="new-ref"><span style="font-size: 115%;">&nbsp;</span></div>
        </div>
        <div id="box-container">
            <canvas id="grid"></canvas>
            <canvas id="objs"></canvas>
        </div>
    </div>
    <script type="text/javascript">
        const MQ = MathQuill.getInterface(2);

        let Graph = {
            pan_x: 0,
            pan_y: 0,
            objects: [],
            selected: null,
            fields: [],
        }

        let Canvas = {
            element: document.getElementById("grid"),
            ctx: null,
            obj_layer: document.getElementById("objs"),
            obj_ctx: null,

            init() {
                const rect = document.getElementById("box-container").getBoundingClientRect();
                this.element.width = rect.width;
                this.element.height = rect.height - 5;

                Graph.pan_x = rect.width/2;
                Graph.pan_y = rect.height/2;

                this.obj_layer.style.left = rect.x + 'px';
                this.obj_layer.style.top = rect.top;
                this.obj_layer.width = rect.width;
                this.obj_layer.height = rect.height - 5;

                this.ctx = this.element.getContext('2d');
                this.obj_ctx = this.obj_layer.getContext('2d')
            },

            update() {
                const size = {
                    x: this.element.clientWidth,
                    y: this.element.clientHeight,
                }

                this.ctx.clearRect(0, 0, size.x, size.y);
                this.obj_ctx.clearRect(0, 0, size.x, size.y);

                this.ctx.lineWidth = 0.5;
                this.ctx.strokeStyle = "#839496";
                this.ctx.fillStyle = "#fdf6e3";

                const number_x_start = Math.trunc(-Graph.pan_x / step);
                const number_y_start = Math.trunc(-Graph.pan_y / step);

                for (let i = 0; i <= Math.trunc(size.x / step) + 1; i++) {
                    if (i + number_x_start != 0) {
                        this.ctx.fillText(
                            String(i + number_x_start),
                            (Graph.pan_x % step) + i * step + 4,
                            Math.min(Math.max(Graph.pan_y + 16, 16), size.y));

                        this.ctx.beginPath();
                        this.ctx.moveTo((Graph.pan_x % step) + i * step, 0);
                        this.ctx.lineTo((Graph.pan_x % step) + i * step, size.y);
                        this.ctx.stroke();
                    }
                }

                for (let i = 0; i <= Math.trunc(size.y / step) + 1; i++) {
                    if (i + number_y_start != 0) {
                        this.ctx.fillText(
                            String(i + number_y_start),
                            Math.min(Math.max(Graph.pan_x + 8, 8), size.x - 16),
                            (Graph.pan_y % step) + i * step - 4);

                        this.ctx.beginPath();
                        this.ctx.moveTo(0, (Graph.pan_y % step) + i * step);
                        this.ctx.lineTo(size.x, (Graph.pan_y % step) + i * step);
                        this.ctx.stroke();
                    }
                }

                this.ctx.lineWidth = 2;
                this.ctx.strokeStyle = "#fdf6e3";

                this.ctx.beginPath();
                this.ctx.moveTo(Graph.pan_x, 0);
                this.ctx.lineTo(Graph.pan_x, size.y);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(0, Graph.pan_y);
                this.ctx.lineTo(size.x, Graph.pan_y);
                this.ctx.stroke();


                this.obj_ctx.lineWidth = 4;

                let environment = {};

                for (const field of Graph.fields) {
                    if (field.ast == undefined) continue;

                    environment[field.obj_name] = {
                        func: field.ast,
                        val: undefined
                    }
                }

                for (const name in environment) {
                    const obj = environment[name];

                    const result = execute_ast(obj.func, environment)

                    this.obj_ctx.strokeStyle = colors[0];
                    this.obj_ctx.fillStyle = colors[0];
                    // this.obj_ctx.strokeStyle = colors[obj.color];
                    // this.obj_ctx.fillStyle = colors[obj.color];

                    // const selected = obj == Graph.selected;

                    if (result instanceof Vec) {
                        draw_arrow(this.obj_ctx,
                            Graph.pan_x, //obj.x1 * step + Graph.pan_x,
                            Graph.pan_y, //obj.y1 * step + Graph.pan_y,
                            result.x * step, //obj.x2 * step,
                            result.y * step, //obj.y2 * step
                        );
                    }
                }
            },
        }

        window.addEventListener("mousemove", e => {
            e.preventDefault();
            if (e.buttons & 2) {
                Graph.pan_x += e.movementX;
                Graph.pan_y += e.movementY;

                Canvas.update();
            } else if (e.buttons & 1) {
                if (Graph.selected) {
                    let [sx, sy] = snap2((e.offsetX - Graph.pan_x)/step, (e.offsetY - Graph.pan_y)/step)
                    Graph.selected.x1 = sx;
                    Graph.selected.y1 = sy;
                }

                Canvas.update();
            }
        })

        window.addEventListener("mousedown", e => {
            if (e.buttons & 1) {
                e.preventDefault();
                
                for (const obj of Graph.objects) {
                    switch (obj.kind) {
                        case 'vector':
                            // this.obj_ctx.beginPath();
                            // draw_arrow(this.obj_ctx,
                            //     obj.x1 * step + Graph.pan_x,
                            //     obj.y1 * step + Graph.pan_y,
                            //     obj.x2 * step + Graph.pan_x,
                            //     obj.y2 * step + Graph.pan_y
                            // );
                            break;
                        case 'point':
                            const [x, y] = [obj.x1 * step + Graph.pan_x, obj.y1 * step + Graph.pan_y]
                            const d = Math.hypot(x - e.offsetX, y - e.offsetY);
                            if (d <= 4) {
                                Graph.selected = obj
                            }
                            break;
                    }

                }

                Canvas.update();
            }
        })

        window.addEventListener("mouseup", e => {
            Graph.selected = null;
        })

        window.addEventListener("resize", e => {
            Canvas.element.width = 0;
            Canvas.element.height = 0;
            Canvas.obj_layer.width = 0;
            Canvas.obj_layer.height = 0;

            const rect = document.getElementById("box-container").getBoundingClientRect();
            Canvas.element.width = rect.width;
            Canvas.element.height = rect.height - 5;

            Graph.pan_x = rect.width/2;
            Graph.pan_y = rect.height/2;

            Canvas.obj_layer.style.left = rect.x + 'px';
            Canvas.obj_layer.style.top = rect.top;
            Canvas.obj_layer.width = rect.width;
            Canvas.obj_layer.height = rect.height - 5;
            
            Canvas.update();
        })


        Canvas.init();
        Canvas.update();

        let p = Point(2, 1);
        Graph.objects.push(p);

        function new_object(color = 0){
            const new_div = document.getElementById('new-ref');
            const defs_div = document.getElementById('defs');
            const div = document.createElement('div');
            const span = document.createElement('span');
            span.classList.add('math-field');
            div.appendChild(span)

            defs_div.insertBefore(div, new_div);

            let v = Vector(0, 0);
            Graph.objects.push(v);
            v.color = color;
            
            let math_field = MQ.MathField(span, {
                handlers: {
                    edit: function() {
                        let format = math_field.text();
                        if (!format) return;
                        let ast
                        try {
                            ast = parse_expression({source: format});
                        } catch(e) {
                            return;
                        }

                        if (ast.kind == 'op' && ast.op == '=') {
                            math_field.ast = ast.rhs;
                            math_field.obj_name = ast.lhs.val;
                        } else {
                            math_field.ast = ast;
                            math_field.obj_name = '_' + String(Math.random());
                        }

                        Canvas.update();
                    }
                },
                autoCommands: 'pi theta sqrt',
            });

            math_field.focus();

            math_field.ast = undefined;
            math_field.obj_name = undefined;

            Graph.fields.push(math_field);
        }

        Canvas.update();
    </script>
</body>
</html>